"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const computer_error_1 = require("./computer-error");
const token_1 = require("./token");
class Tokenizer {
    constructor(line, lineNo) {
        this.line = line;
        this.lineNo = lineNo;
        this.position = 0;
    }
    makeToken(kind, start, end, value) {
        return {
            kind,
            line: this.lineNo,
            start,
            end,
            value: value || this.line.substring(start, end)
        };
    }
    parseNumber() {
        let start = this.position;
        let i = this.position;
        let line = this.line;
        let stop = false;
        for (;; i++) {
            const next = line[i + 1];
            if (next === '.') {
                if (stop)
                    throw new computer_error_1.default("two periods occur in one number", i + 1, this.lineNo);
                stop = true;
                continue;
            }
            if (isLetterOrUnderscore(next))
                throw new computer_error_1.default(`expected number, got ${next}`, i + 1, this.lineNo);
            if (isDigit(next))
                continue;
            break;
        }
        if (line[i] === '.')
            throw new computer_error_1.default("number cannot end with a point", i, this.lineNo);
        this.position = i;
        return this.makeToken(token_1.TokenKind.Const, start, i + 1);
    }
    parseIdentifier() {
        const start = this.position;
        let i = this.position;
        let line = this.line;
        let next = line[i + 1];
        while (isLetterOrUnderscore(next) || isDigit(next))
            next = line[++i + 1];
        this.position = i;
        return this.makeToken(token_1.TokenKind.Identifier, start, i + 1);
    }
    *parse() {
        const lLength = this.line.length;
        for (this.position = 0; this.position < lLength; this.position++) {
            const char = this.line[this.position];
            if (isDigit(char))
                yield this.parseNumber();
            else if (isLetterOrUnderscore(char))
                yield this.parseIdentifier();
            else if (char === '(')
                yield this.makeToken(token_1.TokenKind.OpBracket, this.position, this.position + 1, char);
            else if (char === ')')
                yield this.makeToken(token_1.TokenKind.ClBracket, this.position, this.position + 1, char);
            else if (isOperator(char))
                yield this.makeToken(token_1.TokenKind.Operator, this.position, this.position + 1, char);
            else if (isWhitespace(char))
                continue;
            else
                throw new computer_error_1.default(`expected number, identifier or operator, got ${char}`, this.position, this.lineNo);
        }
    }
}
exports.Tokenizer = Tokenizer;
function isWhitespace(char) {
    return char === ' ' || char === '\t';
}
exports.isWhitespace = isWhitespace;
function isDigit(num) {
    if (num === "" || isWhitespace(num))
        return false;
    for (let i = 0; i < 10; i++)
        if (num == i)
            return true;
    return false;
}
exports.isDigit = isDigit;
function isLetterOrUnderscore(value) {
    if (value === undefined)
        return false;
    return /[A-Za-z_]/.test(value);
}
exports.isLetterOrUnderscore = isLetterOrUnderscore;
function isOperator(value) {
    for (let op of "+-*/@=")
        if (op === value)
            return true;
    return false;
}
exports.isOperator = isOperator;
function isOperatorOrBracket(value) {
    return value === "(" ||
        value === ")" ||
        isOperator(value);
}
exports.isOperatorOrBracket = isOperatorOrBracket;
function* parse(line, lineNo = 1) {
    const tokenizer = new Tokenizer(line, lineNo);
    for (const token of tokenizer.parse())
        yield token.value;
}
exports.parse = parse;
//# sourceMappingURL=tokenizer.js.map