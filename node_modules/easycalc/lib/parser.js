"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const AST = require("./ast");
const tokenizer_1 = require("./tokenizer");
const token_1 = require("./token");
const computer_error_1 = require("./computer-error");
class Parser {
    constructor(tokens) {
        this.tokens = tokens;
        this.currentPos = 0;
    }
    currentToken() { return this.tokens[this.currentPos]; }
    previousToken() { return this.tokens[this.currentPos - 1]; }
    fail(message, token) {
        let t = token || this.currentToken();
        throw new computer_error_1.default(message, t.start, t.line);
    }
    canAcceptOperator(...operators) {
        const token = this.currentToken();
        if (!token || token.kind != token_1.TokenKind.Operator)
            return false;
        if (operators.length === 0)
            return true;
        for (let operator of operators)
            if (token.value === operator)
                return true;
        return false;
    }
    acceptOperator(...operators) {
        const cToken = this.currentToken();
        if (!this.canAcceptOperator(...operators))
            this.fail(`expected operator, got ${cToken.value}`);
        const result = cToken.value;
        this.currentPos++;
        return result;
    }
    parseRest(M, ...operators) {
        if (this.canAcceptOperator(...operators)) {
            const operator = this.acceptOperator();
            const argument = M();
            const rest = this.parseRest(M, ...operators);
            return {
                operator,
                argument,
                rest
            };
        }
    }
    reweightRest(left, rest) {
        if (!rest)
            return left;
        const position = {
            line: left.position.line,
            start: left.position.start,
            end: rest.argument.position.end
        };
        return this.reweightRest(AST.binary(rest.operator, left, rest.argument, position), rest.rest);
    }
    parseAdditionRest() {
        return this.parseRest(() => this.parseMultiplication(), "+", "-");
    }
    parseAddition() {
        const { line, start } = this.currentToken();
        const left = this.parseMultiplication();
        const rest = this.parseAdditionRest();
        const { end } = this.previousToken();
        const result = this.reweightRest(left, rest);
        result.position = { line, start, end };
        return result;
    }
    parseMultiplicationRest() {
        return this.parseRest(() => this.parseAtomicForm(), "*", "/");
    }
    parseMultiplication() {
        const left = this.parseAtomicForm();
        const rest = this.parseMultiplicationRest();
        return this.reweightRest(left, rest);
    }
    parseSimpleAtomicForm() {
        if (this.currentToken().kind == token_1.TokenKind.OpBracket) {
            this.currentPos++;
            const addition = this.parseAddition();
            if (this.currentToken().kind != token_1.TokenKind.ClBracket)
                this.fail(`expected closing bracket, found ${this.currentToken().value}`);
            this.currentPos++;
            return addition;
        }
        return this.parseAtom();
    }
    parseAtomicForm() {
        const { start, line } = this.currentToken();
        if (this.canAcceptOperator("+", "-", "@")) {
            const operator = this.acceptOperator();
            const value = this.parseSimpleAtomicForm();
            return AST.unary(operator, value, { line, start, end: this.previousToken().end });
        }
        return this.parseSimpleAtomicForm();
    }
    parseAtom() {
        const token = this.currentToken();
        if (!token)
            return this.fail(`expected number or identifier, got nothing`);
        try {
            if (token.kind == token_1.TokenKind.Const)
                return AST.constant(token.value, { line: token.line, start: token.start, end: token.end });
            else if (token.kind == token_1.TokenKind.Identifier)
                return AST.identifier(token.value, { line: token.line, start: token.start, end: token.end });
        }
        finally {
            this.currentPos++;
        }
        return this.fail(`expected number or identifier, got ${token.value}`);
    }
    parseAssignment() {
        const curr = this.currentToken();
        const next = this.tokens[this.currentPos + 1];
        if (next && curr.kind === token_1.TokenKind.Identifier && next.kind === token_1.TokenKind.Operator && next.value === "=") {
            const left = this.parseAtom();
            this.acceptOperator("=");
            const right = this.parseAddition();
            return AST.binary("=", left, right, { line: curr.line, start: curr.start, end: right.position.end });
        }
        return this.parseAddition();
    }
    parse() {
        const result = this.parseAssignment();
        const rest = this.currentToken();
        if (!!rest)
            return this.fail(`expected end of line, got ${rest.value}`);
        return result;
    }
}
exports.Parser = Parser;
function parse(line, lineNo = 1) {
    const tokens = Array.from(new tokenizer_1.Tokenizer(line, lineNo).parse());
    return new Parser(tokens).parse();
}
exports.parse = parse;
//# sourceMappingURL=parser.js.map